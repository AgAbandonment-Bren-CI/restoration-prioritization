---
title: "Prioritization of cropland restoration"
authors: "Nickolas McManus and Michelle Geldin"
date: '2022-10-13'
output: 
 html_document: 
    toc: yes
    toc_float: yes
    theme: cerulean
    code_folding: hide
    smooth_scroll: yes
    collapsed: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(prioritizr)    # prioritization package 
library(gurobi)        # optimizaiton software
library(sf)            # associated with prioritizr
library(terra)         # for reading in and altering rasters
library(raster)        # for formating rasters in prioritizr-friendly format
library(geobr)         # geometries for Brazilian boundaries
library(ggplot2)       # visualize some outputs
library(tidyverse)     # always!
library(janitor)       # cleaning up dfs
library(kableExtra)    # tables
```

## Overview
Discuss overall purpose of this analysis. 



## Read in data{.tabset}

First we will read in all the data necessary for formulating and solving the prioritization problem. Broadly, this includes the planning units (locations of projected cropland abandonment), various features (benefits to biodiversity and carbon), and costs of restoration.



### Cropland Abandonment

Read in areas of projected cropland abandonment for five different SSP scenarios in Brazil. These rasters were generated from code located in the `abandoned-cropland` repository, which provides a detailed methodology. Pixel values range from 1 to 7 indicating the frequency of abandonment between 2020 and 2050; values of 1 indicate abandonment only occurred for a five year duration, while pixels with values of 7 were projected to be abandoned for all of 2020-2050.  

Projections of land-use under different SSP scenarios were sourced from:
- Chen, G., Li, X., & Liu, X. (2022). Global land projection based on plant functional types with a 1-km resolution under socio-climatic scenarios. Scientific Data, 9(1), 125. https://doi.org/10.1038/s41597-022-01208-6

```{r}
# read in the cropland abandonment
ssp1_abandoned_crop <- rast("data/inputs/ssp1/SSP1_abandoned_cropland_brazil.tif")
ssp2_abandoned_crop <- rast("data/inputs/ssp2/SSP2_abandoned_cropland_brazil.tif")
ssp3_abandoned_crop <- rast("data/inputs/ssp3/SSP3_abandoned_cropland_brazil.tif")
ssp4_abandoned_crop <- rast("data/inputs/ssp4/SSP4_abandoned_cropland_brazil.tif")
ssp5_abandoned_crop <- rast("data/inputs/ssp5/SSP5_abandoned_cropland_brazil.tif")
```

We also want to figure out which parcels of abandoned cropland are present in every SSP scenario. To solve this, we'll first reclassify the abandoned crop layers to just be a value of 1 (rather than range of 1-7). Then, we'll add these into the combined raster. 
```{r}
reclass_df <- c(1, 7, 1)
reclass_m <- matrix(reclass_df, ncol = 3, byrow = T)

ssp1_reclass <- classify(ssp1_abandoned_crop, reclass_m)
ssp2_reclass <- classify(ssp2_abandoned_crop, reclass_m)
ssp3_reclass <- classify(ssp3_abandoned_crop, reclass_m)
ssp4_reclass <- classify(ssp4_abandoned_crop, reclass_m)
ssp5_reclass <- classify(ssp5_abandoned_crop, reclass_m)

# add together and only keep planning units that overlap in all SSPs
ssp_all_abandoned_crop <- ssp1_reclass + ssp2_reclass + ssp3_reclass + ssp4_reclass + ssp5_reclass
```





### Brazilian Biomes
The boundary information for Brazilian biomes is read-in using the geobr package. Biome polygons are sourced from the Brazilian Institute of Geography and Statistics (IBGE). This dataset uses 2019 IBGE data at scale 1:250.000.

Source: https://www.ibge.gov.br/geociencias/cartas-e-mapas/informacoes-ambientais/15842-biomas.html?=&t=acesso-ao-produto

```{r}
# read in biome boundaries from geobr package
biomes <- read_biomes(
  year = 2019,         #the most recent data available
  simplified = FALSE   #full resolution for boundaries
)

# create vector for whole of Brazil
biomes_vect <- biomes[-7, ] %>%  #remove coastal system biome
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% #change crs to match other rasters
  vect()  #turn sf into vector; easier to crop rasts with


# create vectors for each of the biomes ---------------------------------------
amazon <- biomes %>% 
  filter(code_biome == 1) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

caatinga <- biomes %>% 
  filter(code_biome == 2) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

cerrado <- biomes %>% 
  filter(code_biome == 3) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

atlantic_forest <- biomes %>% 
  filter(code_biome == 4) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

pampa <- biomes %>% 
  filter(code_biome == 5) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

pantanal <- biomes %>% 
  filter(code_biome == 6) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()
```




### Brazilian Regions

Here we read in boundary data for Brazil's five regions: North, Northeast, Central-West, Southeast, and South. In addition to performing a country-wide spatial prioritization, we will also find solutions based on different regional management zones. Although our restoration cost data is broken down by biome, budget allocations are divided by States and Municipalities; therefore, a budget constrained prioritization must be conducted along political rather than ecological boundaries. 
```{r}
# read in region boundaries from geobr package
regions <- read_region(
  year = 2020,         #the most recent data available
  simplified = FALSE   #full resolution for boundaries
)

# turn into vector
regions_vect <- regions %>%  #remove coastal system biome
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()  

# create vectors for each of the regions ------------------------------------
north <- regions %>% 
  filter(code_region == 1) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

n_east <- regions %>% 
  filter(code_region == 2) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

s_east <- regions %>% 
  filter(code_region == 3) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

south <- regions %>% 
  filter(code_region == 4) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()

cent_west <- regions %>% 
  filter(code_region == 5) %>% 
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()
```












### Protected Areas
This dataset is sourced from the World Database of Protected Areas (WDPA). [MORE INFO LATER]

Source: html
-   NOTE: layer from Cam and Shayan are similar, but slightly different. Moving forward in analysis with Cam's for now, but can change the source later.

```{r}
wdpa_poly1 <- vect("data/inputs/WDPA_WDOECM_Dec2022_Public_BRA_shp_0/WDPA_WDOECM_Dec2022_Public_BRA_shp-polygons.shp")
wdpa_poly2 <- vect("data/inputs/WDPA_WDOECM_Dec2022_Public_BRA_shp_1/WDPA_WDOECM_Dec2022_Public_BRA_shp-polygons.shp")
wdpa_poly3 <- vect("data/inputs/WDPA_WDOECM_Dec2022_Public_BRA_shp_2/WDPA_WDOECM_Dec2022_Public_BRA_shp-polygons.shp")

## set crs of polygons equal to rasters
crs(wdpa_poly1) = crs(ssp1_abandoned_crop)
crs(wdpa_poly2) = crs(ssp1_abandoned_crop)
crs(wdpa_poly2) = crs(ssp1_abandoned_crop)

## convert vects to rasts
wdpa_rast1 <- rasterize(wdpa_poly1, ssp1_abandoned_crop, field = "WDPA_PID")


## ------------------------------------------------
## read in combined raster
wdpa <- rast("data/inputs/wdpa_5km_raster.tif")


#change biome crs because it's faster than changing crs of global raster
brazil_trans <- biomes_vect %>% 
  project(y = crs(wdpa))

# crop PAs to terrestrial Brazil
wdpa_crop <- wdpa %>% 
  crop(brazil_trans) %>% 
  mask(brazil_trans) %>%  
  #change crs back to match other rasters
  terra::project(y = crs(biomes_vect)) 


# change resolution from 5kmm to roughly 1km
# to figure out factor that gets res closest to target raster (Chen), use this:
factor <- ceiling(res(wdpa_crop)[1]/res(ssp1_abandoned_crop)[1])
factor

# now change resolution using terra:disagg()
wdpa_disagg <- disagg(wdpa_crop,        #raster 
                            fact = 5,         #disagg factor
                            method = "near")  #categorical values (either PA or not)


# use resample to make resolutions EXACTLY the same
wdpa_resamp <- resample(wdpa_disagg, ssp1_abandoned_crop, method = "near")


# remove Panatnal biome from WDPA layer
wdpa_noPant <- mask(wdpa_resamp, pantanal, inverse = TRUE, updatevalue = NA, touches = TRUE)

# finally, change values so that outside PA is N/A and value of PA is 0
# this is so that the "cost" of these areas are free

## this isn't working!!~!!

wdpa_noPant[wdpa_noPant == 0] <- NA
wdpa_brazil[wdpa_brazil == 100] <- 0
```

```{r}
#how many planning units are in the PAs?
### doesn't work, returns 0 but there are
pus1 <- terra::extract(ssp1_abandoned_crop, wdpa_poly1, fun = 'sum', method = 'simple', na.rm = TRUE)
pus2 <- terra::extract(ssp1_abandoned_crop, wdpa_poly2, fun = 'sum', method = 'simple', na.rm = TRUE)
pus3 <- terra::extract(ssp1_abandoned_crop, wdpa_poly3, fun = 'sum', method = 'simple', na.rm = TRUE)

plot(wdpa_poly1)
plot(ssp1_abandoned_crop, col = "black", add = T)
```


### Carbon
This dataset, originally created by Cook-Patton et al. and updated by Global Forest Watch, estimates the rate of carbon sequestration in aboveground and belowground live biomass during the first 30 years of natural forest regeneration. Spatial sequestration estimates include all forest and savanna biomes in units of MgC/ha/yr at a ~1 km resolution. This carbon data is cropped, masked, and reprojected to match the spatial extent and resolution of other rasters used in the prioritization. Because sequestration data is mostly missing for the Pantanal biome in Brazil, it will be removed from this and all data in the analysis. 

Source: https://data.globalforestwatch.org/documents/gfw::carbon-accumulation-potential-from-natural-forest-regrowth-in-forest-and-savanna-biomes/about

```{r, eval=FALSE}
#NOTE: this code chunk defaults to not evaluate.
#only needs to be run once and cropped raster is saved

# read in carbon layer
carbon_global <- rast("data/inputs/sequestration_rate_mean_aboveground_full_extent_Mg_C_ha_yr.tif")

#cannot crop/mask carbon data when biomes are different crs
#change biome crs because it's faster than changing crs of global raster
brazil_trans <- biomes_vect %>% 
  project(y = crs(carbon_global))

# crop carbon data to Brazil
carbon_brazil <- carbon_global %>% 
  crop(brazil_trans) %>% 
  mask(brazil_trans) %>%  
  #change crs back to match other rasters
  terra::project(y = crs(biomes_vect)) 

# default resolution of carbon layer is 898.8m
# change resolution to match other rasters (1km)
carbon_brazil <- resample(carbon_brazil, ssp1_abandoned_crop, method = "bilinear")

# remove Panatnal biome from carbon layer
carbon_brazil <- mask(carbon_brazil, pantanal, inverse = TRUE, updatevalue = NA, touches = TRUE)

# change the name saved within raster for easier recall
# after stacking feature rasters
names(carbon_brazil) <- "carbon_brazil"

# test plot to visualize results
plot(carbon_brazil)
plot(biomes_vect, add = TRUE)

#export carbon_brazil as intermediate raster
writeRaster(carbon_brazil, "data/outputs/carbon_seq_rate_Brazil.tif", overwrite = TRUE)
```

```{r}
# run below line of code just to read in layer if already created
carbon_brazil <- rast("data/outputs/carbon_seq_rate_Brazil.tif")
```


### Biodiversity
Read in biodiversity data. [Info about the data and where it is from. ]

#### Current/Future biodiversity for prioritization use

After reading in the global layer, we will crop it to Brazil and resample to match the resolution of the planning units. Then, we will reclassify the layer to extinction risk values; this will help set tangible goals of minimizing extinction risk. The final raster will be saved locally, allowing the user to simply read in the layer in the future and only run this code-chunk once. 

```{r, eval=FALSE}
###NOTE: this code chunk defaults to not evaluate.
###only needs to be run once and then cropped raster is saved

#read in global biodiversity data
biodiversity_global <- rast("data/inputs/sparc_conservationPriorities.tif")


#temporarily change biome crs to crop/mask biodiversity data
#faster than changing crs of global raster
brazil_trans <- biomes_vect %>% 
  project(y = crs(biodiversity_global))


# crop biodiversity layer to Brazil
biodiversity_brazil <- biodiversity_global %>% 
  crop(brazil_trans) %>% 
  mask(brazil_trans) %>% 
  #change crs back to match other rasters
  terra::project(y = crs(biomes_vect))


# change resolution of biodiversity layer (4.72km) to match other rasters (1km)
# first use terra:disagg()
biodiversity_brazil <- disagg(biodiversity_brazil, 
                              fact = 5,              
                              method = "bilinear")  
# resample higher res biodiversity to ensure same res and geometries 
# (fine-tuning the res)
biodiversity_brazil <- resample(biodiversity_brazil,ssp1_abandoned_crop, method = "bilinear")

# remove Pantanal biome from biodiversity layer
biodiversity_brazil <- mask(biodiversity_brazil, pantanal, inverse = TRUE, updatevalue = NA)

# change the name saved within raster for easier recall
# after stacking feature rasters
names(biodiversity_brazil) <- "biodiversity_brazil"

# test plot to visualize results
plot(biodiversity_brazil)
plot(biomes_vect, add = TRUE)

#export biodiversity_brazil as intermediate raster
writeRaster(biodiversity_brazil, "data/outputs/sparc_conservationPriorities_Brazil.tif", overwrite = TRUE)




### Now reclassify cropped layer to extinction risk -----------------------------------------
## read in values
extrisk <- read_csv("data/inputs/globalverts_extrisk_scale.csv")

## make three columns for a "from to" reclass
extrisk3 <- extrisk %>%
  # bring rasterval from previous row down as lower bound
  mutate(from = lag(rasterval), .before = 1) %>% 
  # rename rasterval to indicate upper bound
  rename(to = rasterval) %>% 
  # remove resulting na
  drop_na 

# turn csv into matrix
extrisk_m <- data.matrix(extrisk3, rownames.force = NA)

# reclassify raster to extrisk
bio_ext_brazil <- classify(biodiversity_brazil, extrisk_m, right = TRUE)

## save new raster
writeRaster(bio_ext_brazil, "data/outputs/biodiversity_extrisk_brazil.tif")
```

Run below line of code just to read in layer if already created:
```{r}
bio_ext_brazil <- rast("data/outputs/biodiversity_extrisk_brazil.tif")
```


#### Current species richness

We will use the current species richness to compare against our prioritization results. By checking if the areas selected are in the same location as high current species richness, it will help defend the use of the SPARC data. 

```{r}
aoh_rich <- rast("data/inputs/aoh_verts_richness.tif")

#change biome crs because it's faster than changing crs of global raster
brazil_trans <- biomes_vect %>% 
  project(y = crs(aoh_rich))

# crop carbon data to Brazil
bio_rich <- aoh_rich %>% 
  crop(brazil_trans) %>% 
  mask(brazil_trans) %>%  
  #change crs back to match other rasters
  terra::project(y = crs(biomes_vect)) 

plot(bio_rich)

# save raster cropped to Brazil
writeRaster(bio_rich, "data/outputs/aoh_verts_richness_brazil.tif")
```




### Cost Layer
The cost of restoration in Brazil differs with location (by biome), restoration method (six types), and environmental condition of land (favorable or unfavorable). These costs were sourced from a 2017 Nature Conservancy report, written by Rubens de Miranda Benini and Sergio Adeodato. 

```{r}
#read in cost data
costs <- read_csv("data/inputs/tnc_cost_biomes_methods.csv") %>% 
  clean_names()
```







## Prep data for prioritization

Wrangle data into formats suitable for prioritizr inputs. 

### Cost
Select the restoration method and environmental condition you want to investigate for the cost layer. Enter these in the `filter` lines of code. 
Costs are per hectare, so we need to convert it to km^2. Additionally, the costs numbers are too large to use in prioritizr budget, so we need to convert costs to millions per km^2 for ease. 
```{r}
# Looking at conducting natural regeneration and "unfavorable environmental conditions" (CAD)
costs_filtered <- costs %>% 
  filter(restoration_method == "conducting_natural_regeneration") %>% 
  filter(environmental_conditions == "CAD") %>% 
  filter(biome_code != 6) %>%   #remove pantanal data
  select(!c(id, biome)) %>%   #remove id and biome columns
  mutate(cost_mil_r_km = cost_r_ha / 10000,   #convert to cost/km2
         cost_mil_usd_km = cost_usd_ha / 10000,
         .before = 1)

```

To properly assign costs to our planning units, we need to merge our biome data with the filtered cost data. This dataset will then be rasterized for the next step of finalizing our planning units. 
```{r}
# first join biomes with cost layer 
biomes_cost <- biomes %>% 
  full_join(costs_filtered, by = c("code_biome" = "biome_code"))

# turn cost/biome data into a vector
biomes_cost_vect <- biomes_cost[-7, ] %>%   #remove coastal system biome
  st_transform(crs = crs(ssp1_abandoned_crop)) %>%  #change crs to match other rasters
  vect()  

# turn vect into a raster
biomes_cost_rast <- rasterize(x = biomes_cost_vect,      #vect file to rasterize
                              y = ssp1_abandoned_crop,   #raster file to provide example crs and spatial extent
                              field = "cost_mil_r_km")       #values for raster

# remove pantanal biome
biomes_cost_rast <- mask(biomes_cost_rast, pantanal, inverse = TRUE, updatevalue = NA)
```


### Planning Units

Decide on the restoration method and land status desired to analyze the cost, then merge to assign costs to each planning unit.
```{r}
# mask the cost by biomes to abandoned cropland raster
# this will isolate pixels of interest (planning units) with associated cost value
ssp1_pu <- mask(biomes_cost_rast, ssp1_abandoned_crop)
ssp2_pu <- mask(biomes_cost_rast, ssp2_abandoned_crop)
ssp3_pu <- mask(biomes_cost_rast, ssp3_abandoned_crop)
ssp4_pu <- mask(biomes_cost_rast, ssp4_abandoned_crop)
ssp5_pu <- mask(biomes_cost_rast, ssp5_abandoned_crop)
ssp_all_pu <- mask(biomes_cost_rast, ssp_all_abandoned_crop)

```


#### Regional PUs
Take our cost-valued planning units and crop/mask them to a given region
```{r}
## function to crop/mask PUs for a given region
mask_pu_r <- function(ssp, region) {
  ssp_pu <- ssp %>% 
    terra::crop(region, mask = TRUE, touches = TRUE)
  
  ssp_pu <- raster(ssp_pu)
  return(ssp_pu)
}

## SSP1 ----------------------------------------
ssp1_pu_n <- mask_pu_r(ssp1_pu, north)
ssp1_pu_neast <- mask_pu_r(ssp1_pu, n_east)
ssp1_pu_seast <- mask_pu_r(ssp1_pu, s_east)
ssp1_pu_s <- mask_pu_r(ssp1_pu, south)
ssp1_pu_cwest <- mask_pu_r(ssp1_pu, cent_west)

## SSP2 ----------------------------------------
ssp2_pu_n <- mask_pu_r(ssp2_pu, north)
ssp2_pu_neast <- mask_pu_r(ssp2_pu, n_east)
ssp2_pu_seast <- mask_pu_r(ssp2_pu, s_east)
ssp2_pu_s <- mask_pu_r(ssp2_pu, south)
ssp2_pu_cwest <- mask_pu_r(ssp2_pu, cent_west)

## SSP3 ----------------------------------------
ssp3_pu_n <- mask_pu_r(ssp3_pu, north)
ssp3_pu_neast <- mask_pu_r(ssp3_pu, n_east)
ssp3_pu_seast <- mask_pu_r(ssp3_pu, s_east)
ssp3_pu_s <- mask_pu_r(ssp3_pu, south)
ssp3_pu_cwest <- mask_pu_r(ssp3_pu, cent_west)

## SSP4 ----------------------------------------
ssp4_pu_n <- mask_pu_r(ssp4_pu, north)
ssp4_pu_neast <- mask_pu_r(ssp4_pu, n_east)
ssp4_pu_seast <- mask_pu_r(ssp4_pu, s_east)
ssp4_pu_s <- mask_pu_r(ssp4_pu, south)
ssp4_pu_cwest <- mask_pu_r(ssp4_pu, cent_west)

## SSP5 ----------------------------------------
ssp5_pu_n <- mask_pu_r(ssp5_pu, north)
ssp5_pu_neast <- mask_pu_r(ssp5_pu, n_east)
ssp5_pu_seast <- mask_pu_r(ssp5_pu, s_east)
ssp5_pu_s <- mask_pu_r(ssp5_pu, south)
ssp5_pu_cwest <- mask_pu_r(ssp5_pu, cent_west)

## SSP All ----------------------------------------
ssp_all_pu_n <- mask_pu_r(ssp_all_pu, north)
ssp_all_pu_neast <- mask_pu_r(ssp_all_pu, n_east)
ssp_all_pu_seast <- mask_pu_r(ssp_all_pu, s_east)
ssp_all_pu_s <- mask_pu_r(ssp_all_pu, south)
ssp_all_pu_cwest <- mask_pu_r(ssp_all_pu, cent_west)
```



#### Brazil-wide PUs
Prioritizr requires rasters to be in "RasterLayer" format, which requires converting from a 'terra' package raster to a 'raster' package raster. Sometimes this conversion throws and error (for seemingly no reason). The second time, it may convert but drop all the values. Often you have to run this code chunk 2-3 times before obtaining properly converting RasterLayers for all the planning units. Double-check that they have converted properly before moving on!
```{r}
ssp1_pu <- raster(ssp1_pu)
ssp2_pu <- raster(ssp2_pu)
ssp3_pu <- raster(ssp3_pu)
ssp4_pu <- raster(ssp4_pu)
ssp5_pu <- raster(ssp5_pu)
ssp_all_pu <- raster(ssp_all_pu)
```



### Features

To evaluate carbon and biodiversity as features in the prioritization problem, they must be merged into a raster stack.

Here we will mask the biodiversity and carbon layers to the planning units available for in each SSP. This will result in feature layers that reflect the total amount that could be achieved by restoring every planning unit. This makes it easier to set relative targets based on what is possible in the prioritization. However, it means creating a different biodiversity and carbon raster for each SSP. Below we will create a function to generate the necessary feature data rasters, convert them to a prioritizr-friendly raster format, and then stack them according to SSP. 

#### Brazil-wide features
Here we'll create the feature raster stacks for country-wide prioritizr problems.
```{r}
## function will mask Brazil-wide carbon and biodiversity layers
## by planning units for each SSP, then stack raster 
mask_feat_pu <- function(carbon, bio, ssp) {
  # mask brazil carbon layer with SSP pus, then convert to rastLayer
  carbon_pu_ssp <- terra::mask(carbon, ssp) 
  carbon_pu_ssp <- raster(carbon_pu_ssp)
  
  # mask biodiversity layer by SSP pus, then convert
  bio_pu_ssp <- terra::mask(bio, ssp)
  bio_pu_ssp <- raster(bio_pu_ssp)
  
  # stack the rastLayers
  feature_pu_ssp <- stack(carbon_pu_ssp, bio_pu_ssp)
  return(feature_pu_ssp)
}

## Now use function to create feature rastStack for each SSP
## (in future, figure out how to loop this!)
ssp1_feat <- mask_feat_pu(carbon_brazil, bio_ext_brazil, ssp1_abandoned_crop)
ssp2_feat <- mask_feat_pu(carbon_brazil, bio_ext_brazil, ssp2_abandoned_crop)
ssp3_feat <- mask_feat_pu(carbon_brazil, bio_ext_brazil, ssp3_abandoned_crop)
ssp4_feat <- mask_feat_pu(carbon_brazil, bio_ext_brazil, ssp4_abandoned_crop)
ssp5_feat <- mask_feat_pu(carbon_brazil, bio_ext_brazil, ssp5_abandoned_crop)
ssp_all_feat <- mask_feat_pu(carbon_brazil, bio_ext_brazil, ssp_all_abandoned_crop)
```



#### Regional features
Below we create feature stacks for region-specific prioritizr problems.
```{r}
## function to creat feat stack for a given region
mask_feat_pu_r <- function(carbon, bio, ssp, region) {
  # mask carbon to SSP and region then convert
  carbon_pu_ssp <- terra::mask(carbon, ssp)
  carbon_reg <- terra::crop(carbon_pu_ssp, region, mask = TRUE, touches = TRUE) 
  carbon_reg <- raster(carbon_reg)
  # mask biodiversity to SSP then convert
  bio_pu_ssp <- terra::mask(bio, ssp)
  bio_reg <- terra::crop(bio_pu_ssp, region, mask = TRUE, touches = TRUE)
  bio_reg <- raster(bio_reg)
  # stack the rastLayers
  feat_reg <- stack(carbon_reg, bio_reg)
  return(feat_reg)
}

## SSP1 feat regions 
ssp1_feat_n <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp1_abandoned_crop, north)
ssp1_feat_neast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp1_abandoned_crop, n_east)
ssp1_feat_seast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp1_abandoned_crop, s_east)
ssp1_feat_s <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp1_abandoned_crop, south)
ssp1_feat_cwest <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp1_abandoned_crop, cent_west)

## SSP2 feat regions 
ssp2_feat_n <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp2_abandoned_crop, north)
ssp2_feat_neast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp2_abandoned_crop, n_east)
ssp2_feat_seast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp2_abandoned_crop, s_east)
ssp2_feat_s <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp2_abandoned_crop, south)
ssp2_feat_cwest <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp2_abandoned_crop, cent_west)

## SSP3 feat regions 
ssp3_feat_n <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp3_abandoned_crop, north)
ssp3_feat_neast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp3_abandoned_crop, n_east)
ssp3_feat_seast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp3_abandoned_crop, s_east)
ssp3_feat_s <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp3_abandoned_crop, south)
ssp3_feat_cwest <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp3_abandoned_crop, cent_west)

## SSP4 feat regions 
ssp4_feat_n <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp4_abandoned_crop, north)
ssp4_feat_neast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp4_abandoned_crop, n_east)
ssp4_feat_seast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp4_abandoned_crop, s_east)
ssp4_feat_s <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp4_abandoned_crop, south)
ssp4_feat_cwest <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp4_abandoned_crop, cent_west)

## SSP5 feat regions 
ssp5_feat_n <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp5_abandoned_crop, north)
ssp5_feat_neast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp5_abandoned_crop, n_east)
ssp5_feat_seast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp5_abandoned_crop, s_east)
ssp5_feat_s <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp5_abandoned_crop, south)
ssp5_feat_cwest <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp5_abandoned_crop, cent_west)

## SSP all feat regions 
ssp_all_feat_n <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp_all_abandoned_crop, north)
ssp_all_feat_neast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp_all_abandoned_crop, n_east)
ssp_all_feat_seast <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp_all_abandoned_crop, s_east)
ssp_all_feat_s <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp_all_abandoned_crop, south)
ssp_all_feat_cwest <- mask_feat_pu_r(carbon_brazil, bio_ext_brazil, ssp_all_abandoned_crop, cent_west)




####### TEST ZONE ####################################################
## if same target for all zones, can put within matrix fxn
targ <- matrix(0.2, ncol = 5, nrow = 2)
## if different, can customize like this for 2 zones
targ[, 1] <- 0.2
targ[, 2] <- 0.2

z1 <- zones("zone1" = ssp1_feat_n, "zone2" = ssp1_feat_neast, "zone3" = ssp1_feat_seast,
            "zone4" = ssp1_feat_s, "zone5" = ssp1_feat_cwest)

test_north <- mask(ssp1_pu, north)
test_neast <- mask(ssp1_pu, n_east)
test_seast <- mask(ssp1_pu, s_east)
test_south <- mask(ssp1_pu, south)
test_cwest <- mask(ssp1_pu, cent_west)

test_north <- raster(test_north)
test_neast <- raster(test_neast)
test_seast <- raster(test_seast)
test_south <- raster(test_south)
test_cwest <- raster(test_cwest)

test_pu_stack <- stack(test_north, test_neast, test_seast, test_south, test_cwest)

p_test <- problem(test_pu_stack, z1) %>% 
  add_min_shortfall_objective(3400) %>% 
  add_relative_targets(targ) %>% 
  add_gurobi_solver()

S_test <- solve(p_test)



```




## Problem Formulations

This is where we will start formulating the problem to be solved in prioritizr! All base problems will aim to minimize target shortfall while staying within a budget. Relative targets are set for carbon and biodiversity, higher than is possible within the budget (50%). In the spatial solution, it will attempt to get as close to this unattainable target as possible while staying within the budget. Different problems will be created to observe how solutions change based on budget (low and high) as well as Brazil-wide vs zonal problems. 

Below, we'll establish base problems for Brazil-wide scenarios.
```{r}
p1 <- problem(ssp1_pu, ssp1_feat) %>% 
  add_relative_targets(c(0.5, 0.5)) %>% 
  add_gurobi_solver(gap = 0.05)

p2 <- problem(ssp2_pu, ssp2_feat) %>% 
  add_relative_targets(c(0.5, 0.5)) %>% 
  add_gurobi_solver(gap = 0.05)

p3 <- problem(ssp3_pu, ssp3_feat) %>% 
  add_relative_targets(c(0.5, 0.5)) %>% 
  add_gurobi_solver(gap = 0.05)

p4 <- problem(ssp4_pu, ssp4_feat) %>% 
  add_relative_targets(c(0.5, 0.5)) %>% 
  add_gurobi_solver(gap = 0.05)

p5 <- problem(ssp5_pu, ssp5_feat) %>% 
  add_relative_targets(c(0.5, 0.5)) %>% 
  add_gurobi_solver(gap = 0.05)

p_all <- problem(ssp_all_pu, ssp_all_feat) %>% 
  add_relative_targets(c(0.5, 0.5)) %>% 
  add_gurobi_solver(gap = 0.05)
```



### Brazil-wide solutions

For these problems, the low-end budget is 445.892 million Brazilian Reals. To calculate this amount, we looked at the Environmental management budget of Brazil's Ministry of the Environment. In 2022, Brazil only used 85.8% of the allotted budget. We're curious how much land could be restored with the budget "leftovers". This percentage was used to predict how much money may go unused within the Environmental management budget for 2023: roughly BRL445,862,335. 

To determine the potential high-end of a budget, we looked toward the Amazon Fund. This fund receives money from organizations and countries around the world and can be used at the discretion of the Brazilian government to conserve and restore land throughout the country. NGOs can utilize this fund for projects within the Amazon biome, but the Federal government can use these funds for projects throughout the country. We'll evaluate how much abandoned cropland could be restored if Brazil utilized the entire budget currently available in the Amazon fund: BRL3,400,000,000.
```{r}
### SSP1 -----------------------------------------------------

## create problems --------------
# country-wide at low budget
p1_lowBud <- p1 %>% 
  add_min_shortfall_objective(budget = 445.862) 

# country-wide at high budget
p1_highBud <- p1 %>% 
  add_min_shortfall_objective(budget = 3400) 

## solve --------------------------
s1 <- stack(solve(p1_lowBud), solve(p1_highBud))
# rename rasters in stack
names(s1)[1] = "lowBud"
names(s1)[2] = "highBud"

## get solution stats --------------
# returns the number of pus chosen in solution for low budget
#eval_target_coverage_summary(p1_lowBud_c, s1_c$ssp1_lowBud_c)
# returns amount of features held in solution for low budget
#eval_target_coverage_summary(p1_lowBud_c, s1_c$ssp1_lowBud_c)

### SSP2 -----------------------------------------------------

## create problems ----------------
# country-wide at low budget
p2_lowBud <- p2 %>% 
  add_min_shortfall_objective(budget = 445.862)

# country-wide at high budget
p2_highBud <- p2 %>% 
  add_min_shortfall_objective(budget = 3400) 

## solve --------------------------
s2 <- stack(solve(p2_lowBud), solve(p2_highBud))
# rename rasters in stack
names(s2)[1] = "lowBud"
names(s2)[2] = "highBud"


### SSP3 -----------------------------------------------------

## create problems ----------------
# country-wide at low budget
p3_lowBud <- p3 %>% 
  add_min_shortfall_objective(budget = 445.862)

# country-wide at high budget
p3_highBud <- p3 %>% 
  add_min_shortfall_objective(budget = 3400) 

## solve --------------------------
s3 <- stack(solve(p3_lowBud), solve(p3_highBud))
# rename rasters in stack
names(s3)[1] = "lowBud"
names(s3)[2] = "highBud"


### SSP4 -----------------------------------------------------

## create problems ----------------
# country-wide at low budget
p4_lowBud <- p4 %>% 
  add_min_shortfall_objective(budget = 445.862)

# country-wide at high budget
p4_highBud <- p4 %>% 
  add_min_shortfall_objective(budget = 3400)

## solve --------------------------
s4 <- stack(solve(p4_lowBud), solve(p4_highBud))
# rename rasters in stack
names(s4)[1] = "lowBud"
names(s4)[2] = "highBud"


### SSP5 -----------------------------------------------------

## create problems ----------------
# country-wide at low budget
p5_lowBud <- p5 %>% 
  add_min_shortfall_objective(budget = 445.862)

# country-wide at high budget
p5_highBud <- p5 %>% 
  add_min_shortfall_objective(budget = 3400)

## solve --------------------------
s5 <- stack(solve(p5_lowBud), solve(p5_highBud))
# rename rasters in stack
names(s5)[1] = "lowBud"
names(s5)[2] = "highBud"


### All SSPs--------------------------------------------------

## create problems ----------------
# country-wide at low budget
p_all_lowBud <- p_all %>% 
  add_min_shortfall_objective(budget = 445.862)

# country-wide at high budget
p_all_highBud <- p_all %>% 
  add_min_shortfall_objective(budget = 3400) 

## solve --------------------------
s_all <- stack(solve(p_all_lowBud), solve(p_all_highBud))
# rename rasters in stack
names(s_all)[1] = "lowBud"
names(s_all)[2] = "highBud"




##########
# test if there's a difference with 50% vs 100% relative targets


p_all_100 <- problem(ssp_all_pu, ssp_all_feat) %>% 
  add_relative_targets(c(1, 1)) %>% 
  add_min_shortfall_objective(budget = 3400) %>% 
  add_gurobi_solver(gap = 0.05)

s_all_100 <- solve(p_all_100)
```
 

What if budget wasn't a factor? Let's see how much biodiversity and carbon features could be met if 12 million ha (Brazil's goal) of land was restored. To do this, we will convert the costs simply to area and feed these planning units into the prioritization. 

```{r}
#All SSPs with no budget?
noBud_df <- c(0,5, 1)
noBud_m <- matrix(noBud_df, ncol = 3, byrow = TRUE)

ssp_all_pu_noBud <- classify(ssp_all_abandoned_crop, noBud_m)
ssp_all_pu_noBud <- raster(ssp_all_pu_noBud)

p_all_noBud <- problem(ssp_all_pu_noBud, ssp_all_feat) %>% 
  add_relative_targets(c(1, 1)) %>% 
  add_min_shortfall_objective(budget = 120000) %>% 
  add_gurobi_solver(gap = 0.05)

s_all_noBud <- solve(p_all_noBud)

# how many PUs were chosen? answer should be 120,000
eval_n_summary(p_all_noBud, s_all_noBud)
# how much of the targets were met?
eval_target_coverage_summary(p_all_noBud, s_all_noBud)
```




### Regional solutions

Now we will find solutions by breaking the country down by the five regions. We'll create a base problem with a prioritizr function, then use that to find solutions by region and SSP. [info on budget numbers]
```{r}
## create fxn for problem creating
## can't include solving in fxn because eval fxns require calling
## on both the problem and the solution
p_func <- function(pu, feat, targ, budget) {
  p <- prioritizr::problem(pu, feat) %>% 
    add_relative_targets(targ) %>% 
    add_min_shortfall_objective(budget) %>% 
    add_gurobi_solver(gap = 0.05)
  return(p)
}

### North Region ---------------------------------------------------------
## SSP1 
p1_lowBud_n <- p_func(ssp1_pu_n, ssp1_feat_n, c(0.5, 0.5), 37.91)
p1_highBud_n <- p_func(ssp1_pu_n, ssp1_feat_n, c(0.5, 0.5), 289.089)

s1_n <- stack(solve(p1_lowBud_n), solve(p1_highBud_n))
names(s1_n)[1] = "ssp1_lowBud_n"
names(s1_n)[2] = "ssp1_highBud_n"

## SSP2
p2_lowBud_n <- p_func(ssp2_pu_n, ssp2_feat_n, c(0.5, 0.5), 37.91)
p2_highBud_n <- p_func(ssp2_pu_n, ssp2_feat_n, c(0.5, 0.5), 289.089)

s2_n <- stack(solve(p2_lowBud_n), solve(p2_highBud_n))
names(s2_n)[1] = "ssp2_lowBud_n"
names(s2_n)[2] = "ssp2_highBud_n"

## SSP3
p3_lowBud_n <- p_func(ssp3_pu_n, ssp3_feat_n, c(0.5, 0.5), 37.91)
p3_highBud_n <- p_func(ssp3_pu_n, ssp3_feat_n, c(0.5, 0.5), 289.089)

s3_n <- stack(solve(p3_lowBud_n), solve(p3_highBud_n))
names(s3_n)[1] = "ssp3_lowBud_n"
names(s3_n)[2] = "ssp3_highBud_n"

## SSP4 
p4_lowBud_n <- p_func(ssp4_pu_n, ssp4_feat_n, c(0.5, 0.5), 37.91)
p4_highBud_n <- p_func(ssp4_pu_n, ssp4_feat_n, c(0.5, 0.5), 289.089)

s4_n <- stack(solve(p4_lowBud_n), solve(p4_highBud_n))
names(s4_n)[1] = "ssp4_lowBud_n"
names(s4_n)[2] = "ssp4_highBud_n"

## SSP5
p5_lowBud_n <- p_func(ssp5_pu_n, ssp5_feat_n, c(0.5, 0.5), 37.91)
p5_highBud_n <- p_func(ssp5_pu_n, ssp5_feat_n, c(0.5, 0.5), 289.089)

s5_n <- stack(solve(p5_lowBud_n), solve(p5_highBud_n))
names(s5_n)[1] = "ssp5_lowBud_n"
names(s5_n)[2] = "ssp5_highBud_n"

## All SSPs
p_all_lowBud_n <- p_func(ssp_all_pu_n, ssp_all_feat_n, c(1, 1), 37.91)
p_all_highBud_n <- p_func(ssp_all_pu_n, ssp_all_feat_n, c(1, 1), 289.089)

s_all_n <- stack(solve(p_all_lowBud_n), solve(p_all_highBud_n))
names(s_all_n)[1] = "ssp_all_lowBud_n"
names(s_all_n)[2] = "ssp_all_highBud_n"


### North-east Region ---------------------------------------------------------
## SSP1 
p1_lowBud_neast <- p_func(ssp1_pu_neast, ssp1_feat_neast, c(0.5, 0.5), 11.059)
p1_highBud_neast <- p_func(ssp1_pu_neast, ssp1_feat_neast, c(0.5, 0.5), 84.333)

s1_neast <- stack(solve(p1_lowBud_neast), solve(p1_highBud_neast))
names(s1_neast)[1] = "ssp1_lowBud_neast"
names(s1_neast)[2] = "ssp1_highBud_neast"

## SSP2
p2_lowBud_neast <- p_func(ssp2_pu_neast, ssp2_feat_neast, c(0.5, 0.5), 11.059)
p2_highBud_neast <- p_func(ssp2_pu_neast, ssp2_feat_neast, c(0.5, 0.5), 84.333)

s2_neast <- stack(solve(p2_lowBud_neast), solve(p2_highBud_neast))
names(s2_neast)[1] = "ssp2_lowBud_neast"
names(s2_neast)[2] = "ssp2_highBud_neast"

## SSP3
p3_lowBud_neast <- p_func(ssp3_pu_neast, ssp3_feat_neast, c(0.5, 0.5), 11.059)
p3_highBud_neast <- p_func(ssp3_pu_neast, ssp3_feat_neast, c(0.5, 0.5), 84.333)

s3_neast <- stack(solve(p3_lowBud_neast), solve(p3_highBud_neast))
names(s3_neast)[1] = "ssp3_lowBud_neast"
names(s3_neast)[2] = "ssp3_highBud_neast"

## SSP4 
p4_lowBud_neast <- p_func(ssp4_pu_neast, ssp4_feat_neast, c(0.5, 0.5), 11.059)
p4_highBud_neast <- p_func(ssp4_pu_neast, ssp4_feat_neast, c(0.5, 0.5), 84.333)

s4_neast <- stack(solve(p4_lowBud_neast), solve(p4_highBud_neast))
names(s4_neast)[1] = "ssp4_lowBud_neast"
names(s4_neast)[2] = "ssp4_highBud_neast"

## SSP5
p5_lowBud_neast <- p_func(ssp5_pu_neast, ssp5_feat_neast, c(0.5, 0.5), 11.059)
p5_highBud_neast <- p_func(ssp5_pu_neast, ssp5_feat_neast, c(0.5, 0.5), 84.333)

s5_neast <- stack(solve(p5_lowBud_neast), solve(p5_highBud_neast))
names(s5_neast)[1] = "ssp5_lowBud_neast"
names(s5_neast)[2] = "ssp5_highBud_neast"

## All SSPs
p_all_lowBud_neast <- p_func(ssp_all_pu_neast, ssp_all_feat_neast, c(1, 1), 11.059)
p_all_highBud_neast <- p_func(ssp_all_pu_neast, ssp_all_feat_neast, c(1, 1), 84.333)

s_all_neast <- stack(solve(p_all_lowBud_neast), solve(p_all_highBud_neast))
names(s_all_neast)[1] = "ssp_all_lowBud_neast"
names(s_all_neast)[2] = "ssp_all_highBud_neast"


### South-east Region ---------------------------------------------------------
## SSP1 
p1_lowBud_seast <- p_func(ssp1_pu_seast, ssp1_feat_seast, c(0.5, 0.5), 0.40956)
p1_highBud_seast <- p_func(ssp1_pu_seast, ssp1_feat_seast, c(0.5, 0.5), 3.123)

s1_seast <- stack(solve(p1_lowBud_seast), solve(p1_highBud_seast))
names(s1_seast)[1] = "ssp1_lowBud_seast"
names(s1_seast)[2] = "ssp1_highBud_seast"

## SSP2
p2_lowBud_seast <- p_func(ssp2_pu_seast, ssp2_feat_seast, c(0.5, 0.5), 0.40956)
p2_highBud_seast <- p_func(ssp2_pu_seast, ssp2_feat_seast, c(0.5, 0.5), 3.123)

s2_seast <- stack(solve(p2_lowBud_seast), solve(p2_highBud_seast))
names(s2_seast)[1] = "ssp2_lowBud_seast"
names(s2_seast)[2] = "ssp2_highBud_seast"

## SSP3
p3_lowBud_seast <- p_func(ssp3_pu_seast, ssp3_feat_seast, c(0.5, 0.5), 0.40956)
p3_highBud_seast <- p_func(ssp3_pu_seast, ssp3_feat_seast, c(0.5, 0.5), 3.123)

s3_seast <- stack(solve(p3_lowBud_seast), solve(p3_highBud_seast))
names(s3_seast)[1] = "ssp3_lowBud_seast"
names(s3_seast)[2] = "ssp3_highBud_seast"

## SSP4 
p4_lowBud_seast <- p_func(ssp4_pu_seast, ssp4_feat_seast, c(0.5, 0.5), 0.40956)
p4_highBud_seast <- p_func(ssp4_pu_seast, ssp4_feat_seast, c(0.5, 0.5), 3.123)

s4_seast <- stack(solve(p4_lowBud_seast), solve(p4_highBud_seast))
names(s4_seast)[1] = "ssp4_lowBud_seast"
names(s4_seast)[2] = "ssp4_highBud_seast"

## SSP5
p5_lowBud_seast <- p_func(ssp5_pu_seast, ssp5_feat_seast, c(0.5, 0.5), 0.40956)
p5_highBud_seast <- p_func(ssp5_pu_seast, ssp5_feat_seast, c(0.5, 0.5), 3.123)

s5_seast <- stack(solve(p5_lowBud_seast), solve(p5_highBud_seast))
names(s5_seast)[1] = "ssp5_lowBud_seast"
names(s5_seast)[2] = "ssp5_highBud_seast"

## All SSPs
p_all_lowBud_seast <- p_func(ssp_all_pu_seast, ssp_all_feat_seast, c(1, 1), 0.40956)
p_all_highBud_seast <- p_func(ssp_all_pu_seast, ssp_all_feat_seast, c(1,1), 3.123)

s <- solve(p_all_highBud_seast)

s_all_seast <- stack(solve(p_all_lowBud_seast), solve(p_all_highBud_seast))
names(s_all_seast)[1] = "ssp_all_lowBud_seast"
names(s_all_seast)[2] = "ssp_all_highBud_seast"



### South Region ---------------------------------------------------------
## SSP1 
p1_lowBud_s <- p_func(ssp1_pu_s, ssp1_feat_s, c(0.5, 0.5), 0.036)
p1_highBud_s <- p_func(ssp1_pu_s, ssp1_feat_s, c(0.5, 0.5), 0.2736)

s1_s <- stack(solve(p1_lowBud_s), solve(p1_highBud_s))
names(s1_s)[1] = "ssp1_lowBud_s"
names(s1_s)[2] = "ssp1_highBud_s"

## SSP2
p2_lowBud_s <- p_func(ssp2_pu_s, ssp2_feat_s, c(0.5, 0.5), 0.036)
p2_highBud_s <- p_func(ssp2_pu_s, ssp2_feat_s, c(0.5, 0.5), 0.2736)

s2_s <- stack(solve(p2_lowBud_s), solve(p2_highBud_s))
names(s2_s)[1] = "ssp2_lowBud_s"
names(s2_s)[2] = "ssp2_highBud_s"

## SSP3
p3_lowBud_s <- p_func(ssp3_pu_s, ssp3_feat_s, c(0.5, 0.5), 0.036)
p3_highBud_s <- p_func(ssp3_pu_s, ssp3_feat_s, c(0.5, 0.5), 0.2736)

s3_s <- stack(solve(p3_lowBud_s), solve(p3_highBud_s))
names(s3_s)[1] = "ssp3_lowBud_s"
names(s3_s)[2] = "ssp3_highBud_s"

## SSP4 
p4_lowBud_s <- p_func(ssp4_pu_s, ssp4_feat_s, c(0.5, 0.5), 0.036)
p4_highBud_s <- p_func(ssp4_pu_s, ssp4_feat_s, c(0.5, 0.5), 0.2736)

s4_s <- stack(solve(p4_lowBud_s), solve(p4_highBud_s))
names(s4_s)[1] = "ssp4_lowBud_s"
names(s4_s)[2] = "ssp4_highBud_s"

## SSP5
p5_lowBud_s <- p_func(ssp5_pu_s, ssp5_feat_s, c(0.5, 0.5), 0.036)
p5_highBud_s <- p_func(ssp5_pu_s, ssp5_feat_s, c(0.5, 0.5), 0.2736)

s5_s <- stack(solve(p5_lowBud_s), solve(p5_highBud_s))
names(s5_s)[1] = "ssp5_lowBud_s"
names(s5_s)[2] = "ssp5_highBud_s"

## All SSPs
p_all_lowBud_s <- p_func(ssp_all_pu_s, ssp_all_feat_s, c(1, 1), 0.036)
p_all_highBud_s <- p_func(ssp_all_pu_s, ssp_all_feat_s, c(1, 1), 0.2736)

s_all_s <- stack(solve(p_all_lowBud_s), solve(p_all_highBud_s))
names(s_all_s)[1] = "ssp_all_lowBud_s"
names(s_all_s)[2] = "ssp_all_highBud_s"



### Central-West Region ---------------------------------------------------------
## SSP1 
p1_lowBud_cwest <- p_func(ssp1_pu_cwest, ssp1_feat_cwest, c(0.5, 0.5), 0.902)
p1_highBud_cwest <- p_func(ssp1_pu_cwest, ssp1_feat_cwest, c(0.5, 0.5), 6.878)

s1_cwest <- stack(solve(p1_lowBud_cwest), solve(p1_highBud_cwest))
names(s1_cwest)[1] = "ssp1_lowBud_cwest"
names(s1_cwest)[2] = "ssp1_highBud_cwest"

## SSP2
p2_lowBud_cwest <- p_func(ssp2_pu_cwest, ssp2_feat_cwest, c(0.5, 0.5), 0.902)
p2_highBud_cwest <- p_func(ssp2_pu_cwest, ssp2_feat_cwest, c(0.5, 0.5), 6.878)

s2_cwest <- stack(solve(p2_lowBud_cwest), solve(p2_highBud_cwest))
names(s2_cwest)[1] = "ssp2_lowBud_cwest"
names(s2_cwest)[2] = "ssp2_highBud_cwest"

## SSP3
p3_lowBud_cwest <- p_func(ssp3_pu_cwest, ssp3_feat_cwest, c(0.5, 0.5), 0.902)
p3_highBud_cwest <- p_func(ssp3_pu_cwest, ssp3_feat_cwest, c(0.5, 0.5), 6.878)

s3_cwest <- stack(solve(p3_lowBud_cwest), solve(p3_highBud_cwest))
names(s3_cwest)[1] = "ssp3_lowBud_cwest"
names(s3_cwest)[2] = "ssp3_highBud_cwest"

## SSP4 
p4_lowBud_cwest <- p_func(ssp4_pu_cwest, ssp4_feat_cwest, c(0.5, 0.5), 0.902)
p4_highBud_cwest <- p_func(ssp4_pu_cwest, ssp4_feat_cwest, c(0.5, 0.5), 6.878)

s4_cwest <- stack(solve(p4_lowBud_cwest), solve(p4_highBud_cwest))
names(s4_cwest)[1] = "ssp4_lowBud_cwest"
names(s4_cwest)[2] = "ssp4_highBud_cwest"

## SSP5
p5_lowBud_cwest <- p_func(ssp5_pu_cwest, ssp5_feat_cwest, c(0.5, 0.5), 0.902)
p5_highBud_cwest <- p_func(ssp5_pu_cwest, ssp5_feat_cwest, c(0.5, 0.5), 6.878)

s5_cwest <- stack(solve(p5_lowBud_cwest), solve(p5_highBud_cwest))
names(s5_cwest)[1] = "ssp5_lowBud_cwest"
names(s5_cwest)[2] = "ssp5_highBud_cwest"

## All SSPs
p_all_lowBud_cwest <- p_func(ssp_all_pu_cwest, ssp_all_feat_cwest, c(1, 1), 0.902)
p_all_highBud_cwest <- p_func(ssp_all_pu_cwest, ssp_all_feat_cwest, c(1, 1), 6.878)

s_all_cwest <- stack(solve(p_all_lowBud_cwest), solve(p_all_highBud_cwest))
names(s_all_cwest)[1] = "ssp_all_lowBud_cwest"
names(s_all_cwest)[2] = "ssp_all_highBud_cwest"

```



## Saving solution rasters
```{r}
## convert RasterLayers solutions back to SpatRast and export
## these are raster stacks: first layer is low budget and second for high
ssp1_sol <- rast(s1)
crs(ssp1_sol) = crs(ssp1_abandoned_crop)
writeRaster(ssp1_sol, "data/outputs/ssp1_solution_country.tif", overwrite = TRUE)

ssp2_sol <- rast(s2)
crs(ssp2_sol) = crs(ssp1_abandoned_crop)
writeRaster(ssp2_sol, "data/outputs/ssp2_solution_country.tif", overwrite = TRUE)

ssp3_sol <- rast(s3)
crs(ssp3_sol) = crs(ssp1_abandoned_crop)
writeRaster(ssp3_sol, "data/outputs/ssp3_solution_country.tif", overwrite = TRUE)

ssp4_sol <- rast(s4)
crs(ssp4_sol) = crs(ssp1_abandoned_crop)
writeRaster(ssp4_sol, "data/outputs/ssp4_solution_country.tif", overwrite = TRUE)

ssp5_sol <- rast(s5)
crs(ssp5_sol) = crs(ssp1_abandoned_crop)
writeRaster(ssp5_sol, "data/outputs/ssp5_solution_country.tif", overwrite = TRUE)

ssp_all_sol <- rast(s_all)
crs(ssp_all_sol) = crs(ssp1_abandoned_crop)
writeRaster(ssp_all_sol, "data/outputs/ssp_all_solution_country.tif", overwrite = TRUE)
```



Saving some regional stuff (but may not use later)
```{r}
ssp_all_sol_n <- rast(s_all_n)
crs(ssp_all_sol_n) = crs(ssp1_abandoned_crop)
writeRaster(ssp_all_sol_n, "data/outputs/ssp_all_solution_north.tif", overwrite = TRUE)

ssp_all_sol_neast <- rast(s_all_neast)
crs(ssp_all_sol_neast) = crs(ssp1_abandoned_crop)
writeRaster(ssp_all_sol_neast, "data/outputs/ssp_all_solution_northeast.tif", overwrite = TRUE)

ssp_all_sol_seast <- rast(s_all_seast)
crs(ssp_all_sol_seast) = crs(ssp1_abandoned_crop)
writeRaster(ssp_all_sol_seast, "data/outputs/ssp_all_solution_southeast.tif", overwrite = TRUE)

ssp_all_sol_s <- rast(s_all_s)
crs(ssp_all_sol_s) = crs(ssp1_abandoned_crop)
writeRaster(ssp_all_sol_s, "data/outputs/ssp_all_solution_south.tif", overwrite = TRUE)

ssp_all_sol_cwest <- rast(s_all_cwest)
crs(ssp_all_sol_cwest) = crs(ssp1_abandoned_crop)
writeRaster(ssp_all_sol_cwest, "data/outputs/ssp_all_solution_central_west.tif", overwrite = TRUE)
```



Experimenting with boundary length modifiers:
What if we do it with BLM of 50?
```{r, eval= FALSE}
# SSP1 --------------------------------------------
p1_blm50 <- problem(ssp1_pu, features) %>% 
  # minimize cost while ensuring all targets are met
  add_min_set_objective() %>% 
  add_absolute_targets(targets) %>% 
  add_boundary_penalties(penalty = 50) %>% 
  add_gurobi_solver(gap = 0.05)


# SSP2 --------------------------------------------
p2_blm50 <- problem(ssp2_pu, features) %>% 
  add_min_set_objective() %>% 
  add_absolute_targets(targets) %>% 
  add_boundary_penalties(penalty = 50) %>% 
  add_gurobi_solver(gap = 0.05) 


# SSP3 --------------------------------------------
p3_blm50 <- problem(ssp3_pu, features) %>% 
  add_min_set_objective() %>% 
  add_absolute_targets(targets) %>% 
  add_boundary_penalties(penalty = 50) %>% 
  add_gurobi_solver(gap = 0.05)


# SSP4 --------------------------------------------
p4_blm50 <- problem(ssp4_pu, features) %>% 
  add_min_set_objective() %>% 
  add_absolute_targets(targets) %>% 
  add_boundary_penalties(penalty = 50) %>% 
  add_gurobi_solver(gap = 0.05)


# SSP5 --------------------------------------------
p5_blm50 <- problem(ssp5_pu, features) %>% 
  add_min_set_objective() %>% 
  add_absolute_targets(targets) %>% 
  add_boundary_penalties(penalty = 50) %>% 
  add_gurobi_solver(gap = 0.05) 


s1_blm50 <- solve(p1)

s2_blm50 <- solve(p2)

s3_blm50 <- solve(p3)

s4_blm50 <- solve(p4)

s5_blm50 <- solve(p5)

```


## Further analyses

Here we'll compare the prioritizr solutions with further analyses. 
Things to-do:
- create nice table of results
- update costs

```{r}
# reclass the planning unit layers so each cell has a value of 1
# easier for zonal stats
df <- c(0, 3200, 1)
m <- matrix(df, ncol = 3, byrow = TRUE)

pu1 <- classify(ssp1_pu, m) 
names(pu1) <- "pu1"
pu2 <- classify(ssp2_pu, m)
names(pu2) <- "pu2"
pu3 <- classify(ssp3_pu, m)
names(pu3) <- "pu3"
pu4 <- classify(ssp4_pu, m)
names(pu4) <- "pu4"
pu5 <- classify(ssp5_pu, m)
names(pu5) <- "pu5"
pu_all <- classify(ssp_all_pu, m)
names(pu_all) <- 'pu_all'

# Counts ----------------------------------------------------------------------
## How many pus were available?
ab_pu_ssp1 <- sum(freq(pu1)[3])
ab_pu_ssp2 <- sum(freq(pu2)[3])
ab_pu_ssp3 <- sum(freq(pu3)[3])
ab_pu_ssp4 <- sum(freq(pu4)[3])
ab_pu_ssp5 <- sum(freq(pu5)[3])


## how many pus were selected in each? 
picked_1 <- (freq(ssp1_solution)[2, 3])
picked_2 <- (freq(ssp2_solution)[2, 3])
picked_3 <- (freq(ssp3_solution)[2, 3])
picked_4 <- (freq(ssp4_solution)[2, 3])
picked_5 <- (freq(ssp5_solution)[2, 3])

## percent pus chosen
perc_picked_1 <- (picked_1/(ab_pu_ssp1)) * 100
perc_picked_2 <- (picked_2/(ab_pu_ssp2)) * 100
perc_picked_3 <- (picked_3/(ab_pu_ssp3)) * 100
perc_picked_4 <- (picked_4/(ab_pu_ssp4)) * 100
perc_picked_5 <- (picked_5/(ab_pu_ssp5)) * 100

## how many pus overlapped in all five solutions? 
total_pu <- sum(pu1, pu2, pu3, pu4, pu5)

## how many pus were chosen in all five solutions?
total_picked <- freq(total_solution)[6,3]



# Zonal Stats------------------------------------------------------------------


## By Region --------------------------------
regions_rast <- rasterize(x = regions_vect,
                          y = ssp1_abandoned_crop,
                          field = "name_region")
regions_rast_noPant <- mask(regions_rast, pantanal, inverse = TRUE, updatevalue = NA)

## find how many pus per region
ssp_all_zs_pu_region <- zonal(pu_all, regions_rast, 'sum', na.rm = TRUE)

## find how many pus were *prioritized* in each biome
ssp_all_zs_sol_region <- zonal(ssp_all_sol_high, regions_rast, "sum", na.rm = TRUE)



## By Biome --------------------------------
### make raster with biome codes as values
biomes_rast <- rasterize(x = biomes_vect,
                         y = ssp1_abandoned_crop,
                         field = "name_biome")       
### remove pantanal biome
biomes_rast_noPant <- mask(biomes_rast, pantanal, inverse = TRUE, updatevalue = NA)

### find how many pus were present in each biome
ssp1_zs_pu_biome <- zonal(pu1, biomes_rast, "sum", na.rm = TRUE)
ssp2_zs_pu_biome <- zonal(pu2, biomes_rast, "sum", na.rm = TRUE)
ssp3_zs_pu_biome <- zonal(pu3, biomes_rast, "sum", na.rm = TRUE)
ssp4_zs_pu_biome <- zonal(pu4, biomes_rast, "sum", na.rm = TRUE)
ssp5_zs_pu_biome <- zonal(pu5, biomes_rast, "sum", na.rm = TRUE)
ssp_all_zs_pu_biome <- zonal(pu_all, biomes_rast, 'sum', na.rm = T)


### combine all the counts into one table
counts_pu_biome <- full_join(ssp1_zs_pu_biome, ssp2_zs_pu_biome, by = "name_biome") %>% 
  full_join(ssp3_zs_pu_biome, by = "name_biome") %>% 
  full_join(ssp4_zs_pu_biome, by = "name_biome") %>% 
  full_join(ssp5_zs_pu_biome, by = "name_biome")



### find how many pus were *prioritized* in each biome
ssp1_zs_sol_biome <- zonal(ssp1_sol, biomes_rast, "sum", na.rm = TRUE)
ssp2_zs_sol_biome <- zonal(ssp2_sol, biomes_rast, "sum", na.rm = TRUE)
ssp3_zs_sol_biome <- zonal(ssp3_sol, biomes_rast, "sum", na.rm = TRUE)
ssp4_zs_sol_biome <- zonal(ssp4_sol, biomes_rast, "sum", na.rm = TRUE)
ssp5_zs_sol_biome <- zonal(ssp5_sol, biomes_rast, "sum", na.rm = TRUE)
ssp_all_zs_sol_biome <- zonal(ssp_all_sol, biomes_rast, "sum", na.rm = TRUE)

#### combine all the counts into one table
counts_sol_biome <- full_join(ssp1_zs_sol_biome, ssp2_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp3_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp4_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp5_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp_all_zs_sol_biome, by = 'name_biome')


## find how many features are in each biome
# convert zero values to nas to mask properly
ssp_all_sol_high[ssp_all_sol_high == 0] <- NA

ssp_all_bio <- mask(bio_ext_brazil, ssp_all_abandoned_crop)
ssp_all_carbon <- mask(carbon_brazil, ssp_all_abandoned_crop)

ssp_all_bio_sol <- mask(ssp_all_bio, ssp_all_sol_high, updatevalue = NA)
ssp_all_carbon_sol <- mask(ssp_all_carbon, ssp_all_sol_high, updatevalue = NA)

ssp_all_zs_bio_biome <- zonal(ssp_all_bio_sol, biomes_rast, 'sum', na.rm = TRUE)










### combine all the counts into one table
counts_sol_state <- full_join(ssp1_zs_sol_biome, ssp2_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp3_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp4_zs_sol_biome, by = "name_biome") %>% 
  full_join(ssp5_zs_sol_biome, by = "name_biome")


### find overlap between each ssp
total_pu[total_pu == 5] <- 1
overlap_zs_pu_biome <- zonal(total_pu, biomes_rast, "sum", na.rm = TRUE)

overlap_zs_sol_biome <- zonal(total_solution_overlap, biomes_rast,"sum", na.rm = TRUE)

## By State --------------------------------
states <- read_state(year = 2020, simplified = FALSE)

### create vector for states
states_vect <- states %>%  
  st_transform(crs = crs(ssp1_abandoned_crop)) %>% 
  vect()  

### create raster for states
states_rast <- rasterize(x = states_vect,
                         y = ssp1_abandoned_crop,
                         field = "name_state")  %>% 
  mask(mask = pantanal, inverse = TRUE, updatevalue = NA)

### find how many pus were present in each state
ssp1_zs_pu_state <- zonal(pu1, states_rast, "sum", na.rm = TRUE)
ssp2_zs_pu_state <- zonal(pu2, states_rast, "sum", na.rm = TRUE)
ssp3_zs_pu_state <- zonal(pu3, states_rast, "sum", na.rm = TRUE)
ssp4_zs_pu_state <- zonal(pu4, states_rast, "sum", na.rm = TRUE)
ssp5_zs_pu_state <- zonal(pu5, states_rast, "sum", na.rm = TRUE)

### combine all the counts into one table
counts_pu_state <- full_join(ssp1_zs_pu_state, ssp2_zs_pu_state, by = "name_state") %>% 
  full_join(ssp3_zs_pu_state, by = "name_state") %>% 
  full_join(ssp4_zs_pu_state, by = "name_state") %>% 
  full_join(ssp5_zs_pu_state, by = "name_state")

### find how many pus were *prioritized* in each biome
ssp1_zs_sol_state <- zonal(ssp1_solution, states_rast, "sum", na.rm = TRUE)
ssp2_zs_sol_state <- zonal(ssp2_solution, states_rast, "sum", na.rm = TRUE)
ssp3_zs_sol_state <- zonal(ssp3_solution, states_rast, "sum", na.rm = TRUE)
ssp4_zs_sol_state <- zonal(ssp4_solution, states_rast, "sum", na.rm = TRUE)
ssp5_zs_sol_state <- zonal(ssp5_solution, states_rast, "sum", na.rm = TRUE)

### combine all the counts into one table
counts_sol_state <- full_join(ssp1_zs_sol_state, ssp2_zs_sol_state, by = "name_state") %>% 
  full_join(ssp3_zs_sol_state, by = "name_state") %>% 
  full_join(ssp4_zs_sol_state, by = "name_state") %>% 
  full_join(ssp5_zs_sol_state, by = "name_state")
```



Info on carbon and biodiversity layers
```{r}
# carbon --------------------------------------------------------------------

## mean total carbon by biome
carbon_mean <- zonal(ssp_all_feat, biomes_rast, "mean", na.rm = TRUE)

## how much carbon can be stored in each biome?
carbon_sum <- zonal(carbon_brazil, biomes_rast, 'sum', na.rm = TRUE)

## relative percentage of stored carbon in each biome
carbon_amazon <- (carbon_sum[1,2])/(sum(carbon_sum[2]))
carbon_caatinga <- (carbon_sum[2,2])/(sum(carbon_sum[2]))
carbon_cerrado <- (carbon_sum[3,2])/(sum(carbon_sum[2]))
carbon_atl_for <- (carbon_sum[4,2])/(sum(carbon_sum[2]))
carbon_pampa <- (carbon_sum[5,2])/(sum(carbon_sum[2]))

## how much carbon within the planning units across Brazil?


# Biodiversity --------------------------------------------------------------
## how many pixels in each biome
bio_sum <- zonal(biodiv_binary, biomes_rast, 'sum', na.rm = TRUE)

## relative percentage of bio habitat in each biome
bio_amazon <- (bio_sum[1,2])/(sum(bio_sum[2]))
bio_caatinga <- (bio_sum[2,2])/(sum(bio_sum[2]))
bio_cerrado <- (bio_sum[3,2])/(sum(bio_sum[2]))
bio_atl_for <- (bio_sum[4,2])/(sum(bio_sum[2]))
bio_pampa <- (bio_sum[5,2])/(sum(bio_sum[2]))
```


